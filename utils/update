#!/usr/bin/python
##
# Simple script to handle printer configration updates.
##
import argparse
import getpass
import pathlib
import tempfile
import difflib
import stat
import os
import fnmatch
import sys
import moonraker

try:
    import paramiko
except ImportError:
    print("This tool requires python3-paramiko.", file=sys.stderr)
    sys.exit(1)

REMOTE_CONF_PATH = pathlib.PosixPath("klipper_config")
LOCAL_CONF_PATH = pathlib.PosixPath(os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]),
                                                                 "../printer/config")))


class GColor:  # Gnome supported
    END = "\x1b[0m"
    # If Foreground is False that means color effect on Background

    @staticmethod
    def RGB(R, G, B, Foreground=True):  # R: 0-255  ,  G: 0-255  ,  B: 0-255
        # Effect on foreground or background
        FB_G = 38 + (not Foreground and 10 or 0)
        return "\x1b[" + str(FB_G) + ";2;" + str(R) + ";" + str(G) + ";" + str(B) + "m"

    @staticmethod
    def HEX(code, Foreground=True):
        if len(code) != 7 or code[0] != '#':
            raise TypeError("Invaid HEX color code.")
        R, G, B = [code[i:i + 2] for i in range(1, len(code), 2)]
        return GColor.RGB(int(R, 16), int(G, 16), int(B, 16), Foreground)


TITLE_COLOR = GColor.RGB(255, 255, 0)
FILENAME_COLOR = GColor.RGB(0, 255, 255)
REMOVE_COLOR = GColor.RGB(255, 0, 0)
ADD_COLOR = GColor.RGB(0, 255, 0)


class PrinterConfig:
    def __init__(self, connection, remote_root, local_root):
        self.connection = connection
        self.remote_root = pathlib.PosixPath(remote_root)
        self.local_root = pathlib.PosixPath(local_root)
        self.filters = []

    def set_file_filters(self, filters):
        if not isinstance(filters, list):
            filters = [filters]
        self.filters += filters

    def filter_files(self, fileset):
        for filter in self.filters:
            matches = [name for name in fileset
                       if fnmatch.fnmatch(name, filter)]
            for match in matches:
                fileset.remove(match)

        for filename in fileset:
            yield filename

    def __get_remote_files_func(self, root, filtered):
        filenames = self.connection.listdir(root.as_posix())
        if filtered:
            filenames = [pathlib.PosixPath(x)
                         for x in self.filter_files(filenames)]
        remote_files = []
        for filename in filenames:
            st = self.connection.stat((root / filename).as_posix())
            if stat.S_ISDIR(st.st_mode):
                remote_files += self.__get_remote_files_func(
                    root / filename, filtered)
            else:
                remote_files.append(root / filename)
        return remote_files

    def __get_local_files_func(self, root, filtered):
        filenames = []
        for root, dirs, files in os.walk(root):
            root = pathlib.PosixPath(root)
            if filtered:
                filenames += [root / x for x in self.filter_files(files)]
            else:
                filenames = [root / x for x in files]
            for d in dirs:
                filenames += self.__get_local_files_func(root / d, filtered)
        return filenames

    def get_remote_files(self, filtered=True):
        files = self.__get_remote_files_func(self.remote_root, filtered)
        return [x.relative_to(self.remote_root) for x in files]

    def get_local_files(self, filtered=True):
        files = self.__get_local_files_func(self.local_root, filtered)
        return [x.relative_to(self.local_root) for x in files]

    def download_file(self, filename, local_root=None):
        if not local_root:
            local_root = self.local_root
        local_root = pathlib.PosixPath(local_root)
        st = self.connection.stat((self.remote_root / filename).as_posix())
        if stat.S_ISDIR(st.st_mode):
            local_dir = local_root / filename
        else:
            local_dir = local_root / filename.parent
        local_dir.mkdir(exist_ok=True)
        # print(
        #    f"Downloading {self.remote_root / filename} to {local_root / filename}")
        self.connection.get((self.remote_root / filename).as_posix(),
                            (local_root / filename).as_posix())

    def upload_file(self, filename):
        remote_dir = self.remote_root / filename.parent
        try:
            st = self.connection.stat(remote_dir.as_posix())
        except FileNotFoundError:
            for pindex in range(len(remote_dir.parents)-1, -1, -1):
                st = self.connection.stat(
                    (self.remote_root / remote_dir.parents[pindex]).as_posix())
                if stat.S_ISDIR(st.st_mode):
                    continue
                self.connection.mkdir(
                    self.remote_root / remote_dir.parents[pindex].as_posix())
        self.connection.put((self.local_root / filename).as_posix(),
                            (self.remote_root / filename).as_posix())

    def remove_file(self, filename, remove_empty_dirs=False):
        try:
            st = self.connection.stat((self.remote_root / filename).as_posix())
        except FileNotFoundError:
            return
        self.connection.remove((self.remote_root / filename).as_posix())
        if remove_empty_dirs:
            remote_dir = self.remote_root / filename.parent
            while remote_dir != self.remote_root:
                dir_files = self.connection.listdir(remote_dir.as_posix())
                if dir_files:
                    break
                self.connection.rmdir(remote_dir.as_posix())
                remote_dir = remote_dir.parent


def compare_files(file1, file2):
    content1, content2 = [], []
    if file1.exists() and os.access(file1, os.R_OK):
        with (open(file1, 'r')) as fd:
            content1 = fd.readlines()
    else:
        content1 = ""
    if file2.exists() and os.access(file2, os.R_OK):
        with open(file2, 'r') as fd:
            content2 = fd.readlines()
    else:
        content2 = ""
    if content1 == content2:
        return None
    return difflib.unified_diff(content1, content2, str(file1), str(file2))


def pull_config(config, opts, tempdir):
    if not os.path.exists(opts.path):
        os.makedirs(opts.path)
    files = config.get_remote_files(True)
    for filename in files:
        config.download_file(filename)
    return 0


def push_config(config, opts, tempdir):
    files = config.get_local_files(True)
    for filename in files:
        config.upload_file(filename)
    if opts.restart:
        printer = moonraker.Connection(opts.printer)
        printer.firmware_restart()
    return 0


def show_diff(diff):
    for line in diff:
        if line[-1] != "\n":
            line += "\n"
        if line.startswith(("+++", "---")):
            print(f"   {FILENAME_COLOR}{line}{GColor.END}", end="")
        elif line.startswith('+'):
            print(f"   {ADD_COLOR}{line}{GColor.END}", end="")
        elif line.startswith('-'):
            print(f"   {REMOVE_COLOR}{line}{GColor.END}", end="")
        else:
            print(f"   {line}", end="")


def compare_config(config, opts, tempdir):
    remote_files = config.get_remote_files(True)
    for filename in remote_files:
        config.download_file(filename, tempdir)
    file_set = set(config.get_local_files(True)) | set(
        config.get_remote_files(True))
    for filename in file_set:
        result = compare_files(tempdir / filename, opts.path / filename)
        if result:
            print(f"{TITLE_COLOR}{filename}{GColor.END} differs:")
            show_diff(result)
    return 0


def update_config(config, opts, tempdir):
    files_updated = False
    remote_files = config.get_remote_files(True)
    for filename in remote_files:
        config.download_file(filename, tempdir)
    local_files = set(config.get_local_files(True))
    remote_files = set(config.get_remote_files(True))
    for filename in local_files:
        diff = compare_files(tempdir / filename, opts.path / filename)
        if diff:
            answer = "y"
            if opts.ask:
                while True:
                    answer = input(f"Upload {filename}? [y/n/d] ").lower()
                    if answer == "d":
                        show_diff(diff)
                    if answer in ("y", "n"):
                        break
            if answer == "y":
                print(f"Updating {filename}...")
                config.upload_file(filename)
                files_updated = True
        if filename in remote_files:
            remote_files.remove(filename)
    for filename in remote_files - local_files:
        answer = "y"
        if opts.ask:
            while True:
                answer = input(
                    f"File {filename} on printer but not local. Remove? [y/n] ").lower()
                if answer in ("y", "n"):
                    break
        if answer == "y":
            print(f"Removing {filename}...")
            config.remove_file(filename)
            files_updated = True
    if opts.restart and files_updated:
        printer = moonraker.Connection(opts.printer)
        printer.firmware_restart()
    return 0


def clean_temp_dir(path):
    for file in path.iterdir():
        st = (path / file).stat()
        if stat.S_ISDIR(st.st_mode):
            clean_temp_dir(path / file)
        else:
            file.unlink()
    path.rmdir()


def main():
    parser = argparse.ArgumentParser(sys.argv[0],
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--exclude", action="append", default=[],
                        help="Exclude file patterns")
    parser.add_argument("--exclude-file", type=str,
                        help="File containing a list of exclusion patterns.")
    subparser = parser.add_subparsers(title="Operation Modes")
    pull_parser = subparser.add_parser("pull",
                                       formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                       help="Download configuration files.")
    pull_parser.add_argument("--path", type=str, default=LOCAL_CONF_PATH,
                             help="Directory where configuration files will be stored.")
    pull_parser.add_argument("printer", type=str,
                             help="Printer name/address.")
    pull_parser.set_defaults(handler=pull_config)
    push_parser = subparser.add_parser("push",
                                       formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                       help="Upload local configuration to printer.")
    push_parser.add_argument("--path", type=str, default=LOCAL_CONF_PATH,
                             help="Configuration file source directory")
    push_parser.add_argument("--restart", action="store_true",
                             help="Restart firmare after config push.")
    push_parser.add_argument("printer", type=str,
                             help="Printer name/address.")
    push_parser.set_defaults(handler=push_config)
    compare_parser = subparser.add_parser("compare",
                                          formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                          help="Compare configuration files.")
    compare_parser.add_argument("--path", type=str, default=LOCAL_CONF_PATH,
                                help="Configuration file source directory")
    compare_parser.add_argument("printer", type=str,
                                help="Printer name/address.")
    compare_parser.set_defaults(handler=compare_config)
    update_parser = subparser.add_parser("update",
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                         help="Update printer configuration.")
    update_parser.add_argument("--path", type=str, default=LOCAL_CONF_PATH,
                               help="Configuration files source directory.")
    update_parser.add_argument("--ask", action="store_true",
                               help="Ask for confirmation before update file.")
    update_parser.add_argument("--restart", action="store_true",
                               help="Restart firmware after config update.")
    update_parser.add_argument("printer", type=str,
                               help="Printer name/address.")
    update_parser.set_defaults(handler=update_config)
    opts = parser.parse_args(sys.argv[1:])

    if opts.exclude_file:
        with open(opts.exclude_file, 'r') as fd:
            for line in fd:
                if line[0] == "#":
                    continue
                opts.exclude.append(line.strip())

    tempdir = pathlib.PosixPath(tempfile.mkdtemp(prefix="printer_conf.",
                                                 dir="/tmp"))
    tempdir.mkdir(parents=True, exist_ok=True)
    printer_pass = getpass.getpass("Printer access password: ")

    # Create the SSH client
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        client.connect(opts.printer, username="pi",
                       password=printer_pass, allow_agent=False)
    except Exception as err:
        print(f"SSH Connect: {err}")
        sys.exit(1)

    # Open a SFTP connection. This will be the connection that will
    # be used for all transfers
    sftp = client.open_sftp()

    config = PrinterConfig(sftp, REMOTE_CONF_PATH, opts.path)
    config.set_file_filters(opts.exclude)
    status = opts.handler(config, opts, tempdir)

    client.close()
    clean_temp_dir(tempdir)
    return status


if __name__ == "__main__":
    sys.exit(main())

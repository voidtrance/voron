#!/usr/bin/python
##
# Simple script to handle printer configration updates.
##
import argparse
import getpass
import pathlib
import tempfile
import difflib
import stat
import os
import fnmatch
import sys
import moonraker
import configparser
from shutil import copy2 as filecopy

try:
    import paramiko
except ImportError:
    print("This tool requires python3-paramiko.", file=sys.stderr)
    sys.exit(1)

try:
    import git
except ImportError:
    git = None

SCRIPT_PATH = pathlib.PosixPath(os.path.dirname(sys.argv[0])).absolute()
REPO_TOP = SCRIPT_PATH.parent
REMOTE_CONF_PATH = pathlib.PosixPath("klipper_config")
LOCAL_CONF_PATH = pathlib.PosixPath("printer") / "config"
DEFAULT_CONFIG = SCRIPT_PATH / "update.conf"


class GColor:  # Gnome supported
    END = "\x1b[0m"
    # If Foreground is False that means color effect on Background

    @staticmethod
    def RGB(R, G, B, Foreground=True):  # R: 0-255  ,  G: 0-255  ,  B: 0-255
        # Effect on foreground or background
        FB_G = 38 + (not Foreground and 10 or 0)
        return "\x1b[" + str(FB_G) + ";2;" + str(R) + ";" + str(G) + ";" + str(B) + "m"

    @staticmethod
    def HEX(code, Foreground=True):
        if len(code) != 7 or code[0] != '#':
            raise TypeError("Invaid HEX color code.")
        R, G, B = [code[i:i + 2] for i in range(1, len(code), 2)]
        return GColor.RGB(int(R, 16), int(G, 16), int(B, 16), Foreground)


TITLE_COLOR = GColor.RGB(255, 255, 0)
FILENAME_COLOR = GColor.RGB(0, 255, 255)
REMOVE_COLOR = GColor.RGB(255, 0, 0)
ADD_COLOR = GColor.RGB(0, 255, 0)


class PrinterConfig:
    def __init__(self, connection, remote_root, local_root):
        self.connection = connection
        # This is a hack.
        # There is no way to get the user's home directory
        # through an SFTPClient connection. Furthermore, the
        # Paramiko SFTPClient implementation does not recognize
        # the tilde (~) shortchut. Therefoore, we cheat by
        # assuming that a login shell will place us in the
        # user's home directory. And since we don't chdir(),
        # that should remain true for other intances of this
        # class.
        home_dir = pathlib.PosixPath(self.connection.normalize("."))
        first_is_tilde = False
        if isinstance(remote_root, pathlib.Path):
            if remote_root.parts[0] == "~":
                remote_root = home_dir / remote_root.relative_to("~")
        else:
            if remote_root.startswith("~/"):
                remote_root = home_dir / remote_root[2:]
        self.remote_root = pathlib.PosixPath(remote_root)
        self.local_root = pathlib.PosixPath(local_root)
        self.filters = []
        self.file_filters = []

    def set_file_list(self, filters):
        if not isinstance(filters, list):
            filters = [filters]
        for filter in filters:
            if not os.path.isabs(filter):
                filter = "*/" + filter
            self.file_filters.append(filter)

    def set_file_filters(self, filters):
        if not isinstance(filters, list):
            filters = [filters]
        for filter in filters:
            if not os.path.isabs(filter):
                filter = "*/" + filter
            self.filters.append(filter)

    def filter_files(self, fileset):
        if self.file_filters:
            for filename in fileset:
                # for filter in self.file_filters:
                #    print(filename, filter, fnmatch.fnmatch(
                #        filename, filter))
                if [filename for filter in self.file_filters
                        if fnmatch.fnmatch(filename, filter)]:
                    yield filename
        else:
            for filter in self.filters:
                matches = [name for name in fileset
                           if fnmatch.fnmatch(name, filter)]
                for match in matches:
                    fileset.remove(match)

            for filename in fileset:
                yield filename

    def __get_remote_files_func(self, root):
        filenames = self.connection.listdir(root.as_posix())
        remote_files = []
        for filename in filenames:
            st = self.connection.stat((root / filename).as_posix())
            if stat.S_ISDIR(st.st_mode):
                remote_files += \
                    self.__get_remote_files_func(root / filename)
            else:
                remote_files.append(root / filename)
        return remote_files

    def __get_local_files_func(self, root):
        filenames = []
        for root, dirs, files in os.walk(root):
            root = pathlib.PosixPath(root)
            filenames += [root / x for x in files]
        return filenames

    def get_remote_files(self, filtered=True):
        files = self.__get_remote_files_func(self.remote_root)
        if filtered:
            files = list(self.filter_files(files))
        return [x.relative_to(self.remote_root) for x in files]

    def get_local_files(self, filtered=True):
        files = self.__get_local_files_func(self.local_root)
        if filtered:
            files = list(self.filter_files(files))
        return [x.relative_to(self.local_root) for x in files]

    def download_file(self, filename, local_root=None):
        if not local_root:
            local_root = self.local_root
        local_root = pathlib.PosixPath(local_root)
        st = self.connection.stat((self.remote_root / filename).as_posix())
        if stat.S_ISDIR(st.st_mode):
            local_dir = local_root / filename
        else:
            local_dir = local_root / filename.parent
        local_dir.mkdir(parents=True, exist_ok=True)
        # print(
        #    f"Downloading {self.remote_root / filename} to {local_root / filename}")
        self.connection.get((self.remote_root / filename).as_posix(),
                            (local_root / filename).as_posix())

    def upload_file(self, filename, src=None):
        if not src:
            src = self.local_root / filename
        if not src.is_absolute():
            src = self.local_root / src
        remote_dir = self.remote_root / filename.parent
        try:
            st = self.connection.stat(remote_dir.as_posix())
        except FileNotFoundError:
            for pindex in range(len(remote_dir.parents)-1, -1, -1):
                st = self.connection.stat(
                    (self.remote_root / remote_dir.parents[pindex]).as_posix())
                if stat.S_ISDIR(st.st_mode):
                    continue
                self.connection.mkdir(
                    self.remote_root / remote_dir.parents[pindex].as_posix())
        self.connection.put(src.as_posix(),
                            (self.remote_root / filename).as_posix())

    def remove_file(self, filename, remove_empty_dirs=False):
        try:
            st = self.connection.stat((self.remote_root / filename).as_posix())
        except FileNotFoundError:
            return
        self.connection.remove((self.remote_root / filename).as_posix())
        if remove_empty_dirs:
            remote_dir = self.remote_root / filename.parent
            while remote_dir != self.remote_root:
                dir_files = self.connection.listdir(remote_dir.as_posix())
                if dir_files:
                    break
                self.connection.rmdir(remote_dir.as_posix())
                remote_dir = remote_dir.parent


def compare_files(file1, file2):
    content1, content2 = [], []
    if file1.exists() and os.access(file1, os.R_OK):
        with (open(file1, 'r')) as fd:
            content1 = fd.readlines()
    else:
        content1 = ""
    if file2.exists() and os.access(file2, os.R_OK):
        with open(file2, 'r') as fd:
            content2 = fd.readlines()
    else:
        content2 = ""
    if content1 == content2:
        return None
    return difflib.unified_diff(content1, content2, str(file1), str(file2))


def show_diff(diff):
    for line in diff:
        if line[-1] != "\n":
            line += "\n"
        if line.startswith(("+++", "---")):
            print(f"   {FILENAME_COLOR}{line}{GColor.END}", end="")
        elif line.startswith('+'):
            print(f"   {ADD_COLOR}{line}{GColor.END}", end="")
        elif line.startswith('-'):
            print(f"   {REMOVE_COLOR}{line}{GColor.END}", end="")
        else:
            print(f"   {line}", end="")


def user_input(prompt, options=None, default=None):
    if options:
        if default and default not in options:
            default = None
        __options = []
        if isinstance(options, dict):
            __selection = options.keys()
            for option in options:
                prompt += f"\n   {option.capitalize()} - {options[option]}"
            prompt += "\n"
        else:
            __selection = options
        for option in __selection:
            option = option.capitalize()
            __options.append(f"({option})" if option == default else option)
        prompt += f" [{'/'.join(__options)}]"
    while True:
        response = input(f"{prompt} ")
        if not response and default:
            return default
        response = [x for x in options if x.lower() == response.lower()]
        if response:
            return response[0]


def split_diff(diff):
    from_file, to_file, hunk, hunks = None, None, [], []
    for line in diff:
        if line[-1] != "\n":
            line += "\n"
        if line.startswith("---"):
            from_file = pathlib.PosixPath(line.strip()[4:])
        elif line.startswith("+++"):
            to_file = pathlib.PosixPath(line.strip()[4:])
        elif line.startswith("@@"):
            if hunk:
                hunks.append(hunk)
            hunk = [line]
        else:
            hunk.append(line)
    else:
        hunks.append(hunk)
    from_parts = list(from_file.parts)
    from_parts.reverse()
    to_parts = list(to_file.parts)
    to_parts.reverse()
    for i in range(min(len(from_parts), len(to_parts))):
        if from_parts[i] != to_parts[i]:
            break
    if i:
        from_file = from_file.relative_to(from_file.parents[i-1])
        to_file = to_file.relative_to(to_file.parents[i-1])
    else:
        from_file = from_file.name
        to_file = to_file.name
    return from_file, to_file, hunks


def apply_patch(src, dst, path, diff, reversed=False):
    import subprocess

    cmd = ["patch", "-p1"]
    if reversed:
        cmd.append("-R")
    proc = subprocess.Popen(cmd, cwd=path, text=True,
                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT)
    print(f"--- a/{src}")
    print(f"+++ b/{dst}")
    for line in diff:
        print(line, end="")
    proc.stdin.write(f"--- a/{src}\n")
    proc.stdin.write(f"+++ b/{dst}\n")
    proc.stdin.writelines(diff)
    proc.stdin.close()
    status = proc.wait()
    if status != 0:
        for line in proc.stdout.readlines():
            print(line, end="")
    return status


def clean_temp_dir(path):
    for file in path.iterdir():
        st = (path / file).stat()
        if stat.S_ISDIR(st.st_mode):
            clean_temp_dir(path / file)
        else:
            file.unlink()
    path.rmdir()


def config_parser_list_converter(value):
    return [x for x in value.split("\n") if x]


def restart_printer(name):
    printer = moonraker.Connection(name)
    printer.firmware_restart()


def verify_git_repo(path, branch):
    if not git or not branch:
        return True

    repo_path = pathlib.PosixPath(path)
    while repo_path.as_posix() != repo_path.root:
        if (repo_path / ".git").exists():
            break

    if repo_path.as_posix() == repo_path.root:
        return False

    repo = git.Repo(repo_path)
    if repo.active_branch.name == branch:
        return True

    # If the repo is not dirty, we can attempt to
    # switch branches.
    if repo.is_dirty():
        return False

    head = [x for x in repo.heads if x.name == branch]
    if not head:
        return False
    try:
        repo.head = head
        repo.head.reset(index=True, working_tree=True)
    except git.GitError:
        return False
    return True


def update_from_external(src, branch, dest, path, excludes):
    src = REPO_TOP / src
    if not path:
        path = REPO_TOP / LOCAL_CONF_PATH
    dest = pathlib.PosixPath(path) / \
        (REPO_TOP / dest).relative_to(REPO_TOP / LOCAL_CONF_PATH)
    if not src.exists():
        print(f"External source ({src}) not found.")
        return -1
    if not dest.exists():
        print(f"External destination ({dest}) not found.")
        return -1
    if not verify_git_repo(src, branch):
        print(f"External repo branch is not correct")
        return -1
    fileset = [x.relative_to(src) for x in src.iterdir()]
    for pattern in excludes:
        matches = [f for f in fileset if fnmatch.fnmatch(f, pattern)]
        for match in matches:
            fileset.remove(match)

    for filename in fileset:
        if not (dest / filename).exists():
            print(f"File {filename} missing from dest")
        diff = compare_files(src / filename, dest / filename)
        if not diff:
            continue
        try:
            filecopy(src / filename, dest / filename)
        except Exception as err:
            print(err)
            return -1

    return 0


def compare_printer_config(printer, tempdir):
    remote_files = printer.get_remote_files()
    for filename in remote_files:
        printer.download_file(filename, tempdir)
    file_set = set(printer.get_local_files()) | \
        set(printer.get_remote_files())
    for filename in file_set:
        result = compare_files(
            tempdir / filename, printer.local_root / filename)
        if result:
            print(f"{TITLE_COLOR}{filename}{GColor.END} differs:")
            show_diff(result)
    return 0


def compare_config(conn, config, opts, tempdir):
    printer = PrinterConfig(conn, REMOTE_CONF_PATH,
                            opts.path or (REPO_TOP / LOCAL_CONF_PATH))
    printer.set_file_filters(opts.exclude)
    status = compare_printer_config(printer, tempdir)
    if status:
        return status
    for extra in config.getlist("global", "extras"):
        if extra not in config:
            print(f"Section '{extra}' missing from config")
            continue
        printer = PrinterConfig(conn,
                                config.get(extra, "destination"),
                                opts.path or (REPO_TOP / config.get(extra,
                                                                    "source")))
        printer.set_file_list(config.getlist(extra, "files"))
        status = compare_printer_config(printer, tempdir)
        if status:
            break
    return status


def pull_config(conn, config, opts, tempdir):
    if not os.path.exists(opts.path):
        os.makedirs(opts.path)
    printer = PrinterConfig(conn, REMOTE_CONF_PATH,
                            opts.path or (REPO_TOP / LOCAL_CONF_PATH))
    printer.set_file_filters(opts.exclude)
    files = printer.get_remote_files()
    for filename in files:
        printer.download_file(filename)
    for extra in config.getlist("global", "extras"):
        if extra not in config:
            print(f"Section '{extra}' missing from config")
            continue
        printer = PrinterConfig(conn,
                                config.get(extra, "destination"),
                                opts.path or (REPO_TOP / config.get(extra,
                                                                    "source")))
        printer.set_file_list(config.getlist(extra, "files"))
        files = printer.get_remote_files()
        for filename in files:
            printer.download_file(filename)
    return 0


def push_config(conn, config, opts, tempdir):
    if opts.update_external:
        for external in config.getlist("global", "external"):
            if external not in config:
                print(f"Section '{external}' missing from config.")
                continue
            print(f"Update from external source: {external}...")
            if update_from_external(config.get(external, "source"),
                                    config.get(external, "branch", None),
                                    config.get(external, "destination"),
                                    opts.path,
                                    config.getlist(external, "exclude")):
                print(f"External update of {external} failed!")
                return 1

    printer = PrinterConfig(conn, REMOTE_CONF_PATH,
                            opts.path or (REPO_TOP / LOCAL_CONF_PATH))
    printer.set_file_filters(opts.exclude)
    files = printer.get_local_files()
    for filename in files:
        printer.upload_file(filename)
    for extra in config.getlist("global", "extras"):
        if extra not in config:
            print(f"Section '{extra}' missing from config")
            continue
        printer = PrinterConfig(conn,
                                config.get(extra, "destination"),
                                opts.path or (REPO_TOP / config.get(extra,
                                                                    "source")))
        printer.set_file_list(config.getlist(extra, "files"))
        files = printer.get_local_files()
        for filename in files:
            printer.upload_file(filename)
    if opts.restart:
        restart_printer(opts.printer)
    return 0


def update_printer_config(printer, tempdir, ask):
    files_updated = False
    local_files = set(printer.get_local_files(True))
    remote_files = set(printer.get_remote_files(True))
    for filename in remote_files:
        printer.download_file(filename, tempdir)
    for filename in local_files:
        diff = compare_files(tempdir / filename, printer.local_root / filename)
        if diff:
            answer = "y"
            if ask:
                while True:
                    answer = user_input(f"Upload {filename}?", ["y", "n", "d"])
                    if answer == "d":
                        show_diff(diff)
                    else:
                        break
            if answer == "y":
                print(f"Updating {filename}...")
                printer.upload_file(filename)
                files_updated = True
        if filename in remote_files:
            remote_files.remove(filename)
    for filename in remote_files - local_files:
        answer = "y"
        if ask:
            answer = user_input(f"File {filename} on printer but not local. Remove?",
                                ["y", "n"])
        if answer == "y":
            print(f"Removing {filename}...")
            printer.remove_file(filename)
            files_updated = True
    return files_updated


def update_config(conn, config, opts, tempdir):
    if opts.update_external:
        for external in config.getlist("global", "external"):
            if external not in config:
                print(f"Section '{external}' missing from config.")
                continue
            print(f"Update from external source: {external}...")
            if update_from_external(config.get(external, "source"),
                                    config.get(external, "branch", None),
                                    config.get(external, "destination"),
                                    opts.path,
                                    config.getlist(external, "exclude")):
                print(f"External update of {external} failed!")
                return 1

    printer = PrinterConfig(conn, REMOTE_CONF_PATH,
                            opts.path or (REPO_TOP / LOCAL_CONF_PATH))
    printer.set_file_filters(opts.exclude)
    files_updated = update_printer_config(printer, tempdir, opts.ask)
    for extra in config.getlist("global", "extras"):
        if extra not in config:
            print(f"Section '{extra}' missing from config")
            continue
        printer = PrinterConfig(conn,
                                config.get(extra, "destination"),
                                opts.path or (REPO_TOP / config.get(extra,
                                                                    "source")))
        printer.set_file_list(config.getlist(extra, "files"))
        files_updated |= update_printer_config(printer, tempdir, opts.ask)
    if opts.restart and files_updated:
        restart_printer(opts.printer)
    return 0


def sync_printer_config(printer, tempdir):
    files_updated = 0
    local_files = set(printer.get_local_files(True))
    remote_files = set(printer.get_remote_files(True))
    for filename in remote_files:
        try:
            printer.download_file(filename, tempdir)
        except:
            print(remote_files, filename, tempdir)
    for filename in local_files:
        if filename not in remote_files:
            response = user_input(f"Local file {FILENAME_COLOR}{filename}{GColor.END} not on printer. Upload it?",
                                  ["y", "n"], "y")
            if response == "y":
                printer.upload_file(filename)
                files_updated += 1
            continue
        else:
            remote_files.remove(filename)
        diff = compare_files(tempdir / filename, printer.local_root / filename)
        if not diff:
            continue

        # Turn the diff generator into a list since generators can't be
        # reset
        diff = list(diff)
        show_diff(diff)
        response = user_input(f"File {FILENAME_COLOR}{filename}{GColor.END} differs.",
                              {"u": "Upload local file.",
                               "d": "Download remote file.",
                               "s": "Skip this file.",
                               "p": "Select individual changes to apply.",
                               "q": "Quit"})
        if response == "u":
            printer.upload_file(filename)
        elif response == "d":
            printer.download_file(filename, REPO_TOP / LOCAL_CONF_PATH)
        elif response == "s":
            continue
        elif response == "q":
            return files_updated
        elif response == "p":
            local_patch_content = []
            remote_patch_content = []
            ffile, tfile, hunks = split_diff(diff)
            for hunk in hunks:
                hunk_diff = [f"--- {ffile}", f"+++ {tfile}"] + hunk
                show_diff(hunk_diff)
                response = user_input("Apply hunk?",
                                      {"l": "Apply to local file",
                                       "r": "Apply to remote file",
                                       "n": "Don't apply"})
                if response == "l":
                    for line in hunk:
                        local_patch_content.append(line)
                elif response == "r":
                    for line in hunk:
                        remote_patch_content.append(line)
            if local_patch_content:
                if apply_patch(ffile, tfile, printer.local_root,
                               local_patch_content, True):
                    return files_updated
            if remote_patch_content:
                if apply_patch(ffile, tfile, tempdir, remote_patch_content):
                    return files_updated
                printer.upload_file(filename, ffile)
                files_updated += 1
    return files_updated


def sync_config(conn, config, opts, tempdir):
    if opts.update_external:
        for external in config.getlist("global", "external"):
            if external not in config:
                print(f"Section '{external}' missing from config.")
                continue
            print(f"Update from external source: {external}...")
            if update_from_external(config.get(external, "source"),
                                    config.get(external, "branch", None),
                                    config.get(external, "destination"),
                                    opts.path,
                                    config.getlist(external, "exclude")):
                print(f"External update of {external} failed!")
                return 1

    printer = PrinterConfig(conn, REMOTE_CONF_PATH,
                            opts.path or (REPO_TOP / LOCAL_CONF_PATH))
    printer.set_file_filters(opts.exclude)
    files_updated = sync_printer_config(printer, tempdir)
    for extra in config.getlist("global", "extras"):
        if extra not in config:
            print(f"Section '{extra}' missing from config")
            continue
        printer = PrinterConfig(conn,
                                config.get(extra, "destination"),
                                opts.path or (REPO_TOP / config.get(extra,
                                                                    "source")))
        printer.set_file_list(config.getlist(extra, "files"))
        files_updated += sync_printer_config(printer, tempdir)
    if opts.restart and files_updated:
        restart_printer(opts.printer)
    return 0


def main():
    parser = argparse.ArgumentParser(sys.argv[0],
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--config", default=DEFAULT_CONFIG,
                        help="Tool configuration file.")
    parser.add_argument("--exclude", action="append", default=[],
                        help="Exclude file patterns")
    parser.add_argument("--username",
                        help="""Username to use when connection to the printer.
                        This value overrides any username specified in the
                        config file.""")
    common = argparse.ArgumentParser(add_help=False)
    common.add_argument("printer", type=str, nargs="?", default=None,
                        help="""Printer name/address. If not give, the printer
                             name specified in the config file will be used.""")
    subparser = parser.add_subparsers(title="Operation Modes")
    pull_parser = subparser.add_parser("pull",
                                       formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                       parents=[common],
                                       help="Download configuration files.")
    pull_parser.add_argument("--path", type=str, default=None,
                             help="Directory where configuration files will be stored.")
    pull_parser.set_defaults(handler=pull_config)
    push_parser = subparser.add_parser("push",
                                       formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                       parents=[common],
                                       help="Upload local configuration to printer.")
    push_parser.add_argument("--path", type=str, default=None,
                             help="Configuration file source directory")
    push_parser.add_argument("--restart", action="store_true",
                             help="Restart firmare after config push.")
    push_parser.set_defaults(handler=push_config)
    compare_parser = subparser.add_parser("compare",
                                          formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                          parents=[common],
                                          help="Compare configuration files.")
    compare_parser.add_argument("--path", type=str, default=None,
                                help="Configuration file source directory")
    compare_parser.set_defaults(handler=compare_config)
    update_parser = subparser.add_parser("update",
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                         parents=[common],
                                         help="""Update printer configuration. This (selectively)
                                         pushes local files to the printer.""")
    update_parser.add_argument("--path", type=str, default=None,
                               help="Configuration files source directory.")
    update_parser.add_argument("--ask", action="store_true",
                               help="Ask for confirmation before update file.")
    update_parser.add_argument("--restart", action="store_true",
                               help="Restart firmware after config update.")
    update_parser.add_argument("--update-external", action="store_true",
                               help="Do update from external sources.")
    update_parser.set_defaults(handler=update_config)
    sync_parser = subparser.add_parser("sync",
                                       formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                       parents=[common],
                                       help="""Synchronize printer configuration.
                                       Unlike 'update' this option allows for differences
                                       in configuration to be applied in both directions.""")
    sync_parser.add_argument("--path", type=str, default=None,
                             help="Configuration files source directory.")
    sync_parser.add_argument("--restart", action="store_true",
                             help="Restart firmware after config update.")
    sync_parser.add_argument("--update-external", action="store_true",
                             help="Do update from external sources.")
    sync_parser.set_defaults(handler=sync_config)
    opts = parser.parse_args(sys.argv[1:])

    config = configparser.ConfigParser(
        converters={"list": config_parser_list_converter})
    config.read(opts.config)

    if not config.has_section("global"):
        print("'global' section missing from configuration!")
        return 1

    opts.printer = opts.printer or config.get("global", "printer",
                                              fallback=None)
    if not opts.printer:
        print("Printer name must be provided!")
        return 1

    opts.username = opts.username or config.get("global", "username",
                                                fallback=None)
    if not opts.username:
        print("Printer username must be provided!")
        return 1

    for exclude in config.getlist("global", "exclude"):
        opts.exclude.append(exclude)

    tempdir = pathlib.PosixPath(tempfile.mkdtemp(prefix="printer_conf.",
                                                 dir="/tmp"))
    tempdir.mkdir(parents=True, exist_ok=True)

    # Create the SSH client
    try:
        printer_pass = getpass.getpass(
            f"Printer '{opts.printer}' access password: ")
    except KeyboardInterrupt:
        print()
        return 0

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        client.connect(opts.printer, username=opts.username,
                       password=printer_pass, allow_agent=False)
    except Exception as err:
        print(f"SSH Connect: {err}")
        return 1

    # Open a SFTP connection. This will be the connection that will
    # be used for all transfers
    sftp = client.open_sftp()
    status = opts.handler(sftp, config, opts, tempdir)
    client.close()
    clean_temp_dir(tempdir)
    return status


if __name__ == "__main__":
    sys.exit(main())
